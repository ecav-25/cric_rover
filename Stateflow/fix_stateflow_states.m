function fix_stateflow_states(buildInfo)
    % fix_stateflow_states
    %
    % DESCRIPTION:
    %   1. Analyzes the .c files generated by the build process.
    %   2. Moves Stateflow state definitions (_IN_...) from the .c file to the .h file
    %      (to make them visible externally).
    %   3. Automatically copies the files to the correct Git repository folder based on the filename.
    %
    % USAGE:
    %   In Simulink: Code Generation -> Custom Code -> Post-code generation command:
    %   fix_stateflow_states(buildInfo)

    % 1. Get the list of generated source files
    srcFiles = buildInfo.getSourceFiles(true, true); 
    
    if isempty(srcFiles)
        disp('No source files found in buildInfo.');
        return;
    end

    % 2. Loop through all generated files
    for i = 1:length(srcFiles)
        fullCPath = srcFiles{i};
        [filePath, name, ext] = fileparts(fullCPath);
        
        % Safety check: process only .c files
        if ~strcmp(ext, '.c')
            continue; 
        end
       
        if contains(name, '_data') || contains(name, 'ert_main')
            continue;
        end

        if contains(name, '_functions')
            fprintf('  [SKIP] Skip custom file: %s\n', name);
            continue; 
        end
        % -------------------------------
        
        % Define the corresponding header file path
        fullHPath = fullfile(filePath, [name '.h']);
        
        if isfile(fullCPath) && isfile(fullHPath)
            fprintf('Processing: %s ...\n', name);
            
            % A. Modify the code (Move states from .c to .h)
            process_single_pair(fullCPath, fullHPath, name);
            
            % B. Copy files to the correct Firmware repository
            copy_to_firmware_folder(filePath, name);
        end
    end
end

function process_single_pair(cFile, hFile, modelName)
    % Read .C file content
    cContent = fileread(cFile);
    
    % Find the start and end of the constants/states block
    % Embedded Coder sometimes changes comments slightly, check both cases
    startMarker = '/* Named constants for Chart:';
    idxStart = strfind(cContent, startMarker);
    if isempty(idxStart)
        idxStart = strfind(cContent, '/* Named constants');
    end
    
    if isempty(idxStart)
        % If nothing is found, Stateflow might not be present or comments differ
        return; 
    end
    
    % Find the end of the block
    endMarker = '/* Block states';
    idxEnd = strfind(cContent, endMarker);
    
    % Fallback if the end marker is different (often ends where DW_ starts)
    if isempty(idxEnd)
         idxEnd = strfind(cContent, 'DW_');
    end
    
    if isempty(idxEnd)
        return; 
    end
    
    validStart = idxStart(1);
    validEnd = idxEnd(1);
    
    if validStart > validEnd
        return;
    end
    
    % Extract the text block
    fullBlock = cContent(validStart : validEnd-1);
    
    % FILTER: Separate STATE lines (_IN_) from other constants
    lines = split(fullBlock, newline);
    linesStates = {};
    linesConstants = {};
    
    for k = 1:length(lines)
        line = lines{k};
        % Skip empty lines
        if isempty(regexprep(line, '^\s+|\s+$', '')), continue; end 
        
        % Logic: If it contains "_IN_" or " IN_", it's a Stateflow state
        if contains(line, '_IN_') || contains(line, ' IN_')
            linesStates{end+1} = line;
        else
            linesConstants{end+1} = line;
        end
    end
    
    if isempty(linesStates)
        return; % No states to move
    end

    % --- REWRITE THE .C FILE ---
    % Put only non-state constants back into the .C file
    blockForC = strjoin(linesConstants, newline);
    newCContent = [cContent(1:validStart-1), blockForC, newline, newline, cContent(validEnd:end)];
    
    fid = fopen(cFile, 'w');
    if fid ~= -1
        fwrite(fid, newCContent);
        fclose(fid);
    end
    
    % --- REWRITE THE .H FILE ---
    hContent = fileread(hFile);
    
    % Find a safe place to insert enums. 
    % Usually after type includes or before the final endif.
    insertTag = [modelName '_types.h"'];
    idxInsert = strfind(hContent, insertTag);
    
    if isempty(idxInsert)
        % Fallback: Look for rtwtypes.h include
        idxInsert = strfind(hContent, 'rtwtypes.h"');
    end
    
    if isempty(idxInsert)
        % Extreme fallback: Look for #endif and write before it
        idxInsert = strfind(hContent, '#endif'); 
        if ~isempty(idxInsert)
            idxInsert = idxInsert(1); % Take the first #endif if nested poorly (rare in main header)
            % However, we must be careful not to break guards.
        end
    end
    
    if ~isempty(idxInsert)
        % If we found an include, write IMMEDIATELY AFTER it
        if contains(hContent(idxInsert:min(end, idxInsert+50)), '.h"')
             % We found the include line, move to the next line
             splitPos = idxInsert + length(insertTag);
             % Find the next newline to avoid writing mid-line
             nextNewLine = strfind(hContent(splitPos:end), newline);
             if ~isempty(nextNewLine)
                 splitPos = splitPos + nextNewLine(1);
             end
        else
             % Fallback (e.g., we are at #endif), write before it
             splitPos = idxInsert(1) - 1;
        end
        
        if splitPos > length(hContent), splitPos = length(hContent); end
        
        blockForH = strjoin(linesStates, newline);
        
        newHContent = [hContent(1:splitPos), ...
                       newline, newline, ...
                       '/* --- Stateflow States --- */', newline, ...
                       blockForH, newline, ...
                       '/* ------------------------------------------ */', newline, ...
                       hContent(splitPos+1:end)];
        
        fid = fopen(hFile, 'w');
        if fid ~= -1
            fwrite(fid, newHContent);
            fclose(fid);
            fprintf('  [OK] States moved to header for %s\n', modelName);
        end
    end
end

function copy_to_firmware_folder(sourceDir, modelName)
    % This function determines where to copy files based on the model name.
    % Supports names like "Board1", "Board1_supervision", etc.
    
    % --- BASE PATH CONFIGURATION ---
    baseRepoPath = 'repository_name';
    
    % --- FOLDER SELECTION LOGIC ---
    % Convert to lowercase for case-insensitive comparison
    lowerName = lower(modelName);
    
    if contains(lowerName, 'board1')
        % It belongs to Board 1
        targetSrcDir = fullfile(baseRepoPath, 'Board1', 'board1_firmware', 'Core', 'Src');
        targetIncDir = fullfile(baseRepoPath, 'Board1', 'board1_firmware', 'Core', 'Inc');
        
    elseif contains(lowerName, 'board2')
        % It belongs to Board 2
        targetSrcDir = fullfile(baseRepoPath, 'Board2', 'board2_firmware', 'Core', 'Src');
        targetIncDir = fullfile(baseRepoPath, 'Board2', 'board2_firmware', 'Core', 'Inc');
        
    else
        % If the file matches neither Board1 nor Board2 (e.g., generic shared libs),
        % we might want to skip or copy to a common folder.
        % Skipping for now.
        % fprintf('  [SKIP] %s does not match Board1 or Board2 naming convention.\n', modelName);
        return;
    end
    
    fprintf('  [COPY] Copying artifacts for %s to Firmware Repo...\n', modelName);
    
    % --- 1. Copy Source File (.c) ---
    cFile = fullfile(sourceDir, [modelName '.c']);
    if isfile(cFile)
        try
            copyfile(cFile, targetSrcDir, 'f'); % 'f' forces overwrite
            fprintf('    -> .c Copied to .../Core/Src\n');
        catch ME
            fprintf('    [!] Error copying .c file: %s\n', ME.message);
        end
    end
    
    % --- 2. Copy Header Files (.h) ---
    % List of common generated headers
    headersToCopy = {
        [modelName '.h'], ...
        [modelName '_private.h'], ...
        [modelName '_types.h'], ...
        'rtwtypes.h', ...
    };
    
    for i = 1:length(headersToCopy)
        hName = headersToCopy{i};
        hPath = fullfile(sourceDir, hName);
        
        if isfile(hPath)
            try
                copyfile(hPath, targetIncDir, 'f');
                fprintf('    -> %s Copied to .../Core/Inc\n', hName);
            catch ME
                fprintf('    [!] Error copying %s: %s\n', hName, ME.message);
            end
        end
    end
    fprintf('  [DONE] %s synced.\n', modelName);
end

% set_param('model_name', 'PostCodeGenCommand', 'fix_stateflow_states(buildInfo)');